{"version":3,"sources":["tabset.ts"],"names":[],"mappings":"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","file":"tabset.js","sourceRoot":"","sourcesContent":["import {Component, ContentChildren, QueryList, AfterContentInit} from '@angular/core';\r\nimport {SuiTabHeader} from './tab-header';\r\nimport {SuiTabContent} from './tab-content';\r\nimport {Tab} from './tab';\nexport class SuiTabset implements AfterContentInit {\nprivate _tabHeaders:QueryList<SuiTabHeader>;\nprivate _tabContents:QueryList<SuiTabContent>;\npublic tabs:Tab[];\nprivate _activeTab:Tab;\n/**\n * @return {?}\n */\npublic get activeTab() {\r\n        return this._activeTab;\r\n    }\n/**\n * @param {?} tab\n * @return {?}\n */\npublic set activeTab(tab:Tab) {\r\n        this._activeTab = tab;\r\n        tab.isActive = true;\r\n    }\nprivate _barrierCount:number;\nconstructor() {\r\n        this.tabs = [];\r\n        this._barrierCount = 0;\r\n    }\n/**\n * @return {?}\n */\npublic ngAfterContentInit() {\r\n        // Fire `internalComponentsUpdated` when the query lists change.\r\n        this._tabHeaders.changes.subscribe(() => this.internalComponentsUpdated());\r\n        this._tabContents.changes.subscribe(() => this.internalComponentsUpdated());\r\n\r\n        // Initially load the tabs.\r\n        this.loadTabs();\r\n    }\n/**\n * @return {?}\n */\nprivate internalComponentsUpdated() {\r\n        // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.\r\n        // This is so that both the headers and contents query lists can update before we run code that matches the two up.\r\n        this._barrierCount++;\r\n\r\n        if (this._barrierCount == 2) {\r\n            // Reset the barrier so it can be called again.\r\n            this._barrierCount = 0;\r\n\r\n            // Update the tabs.\r\n            this.loadTabs();\r\n        }\r\n    }\n/**\n * @return {?}\n */\nprivate loadTabs() {\r\n        // Remove any tabs that no longer have an associated header.\r\n        this.tabs = this.tabs.filter(t => !!this._tabHeaders.find(tH => tH == t.header));\r\n\r\n        this._tabHeaders\r\n            // Filter out the loaded headers with attached tab instances.\r\n            .filter(tH => !this.tabs.find(t => t.header == tH))\r\n            .forEach(tH => {\r\n                // Create a new tab instance for this header & content combo.\r\n                const /** @type {?} */ tab = new Tab(tH, this._tabContents.find(tC => tC.id == tH.id));\r\n\r\n                if (!tab.content) {\r\n                    // Error if an associated tab content cannot be found for the given header.\r\n                    throw new Error(\"A [suiTabHeader] must have a related [suiTabContent].\");\r\n                }\r\n\r\n                // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.\r\n                tab.header.isActiveExternalChange.subscribe(() => this.onHeaderActiveChanged(tab));\r\n\r\n                // Add the new instance to the list of tabs.\r\n                this.tabs.push(tab);\r\n            });\r\n\r\n        // Assign each tab an index (which denotes the order they physically appear in).\r\n        this._tabHeaders\r\n            .forEach((tH, i) => this.tabs.find(t => t.header == tH).index = i);\r\n\r\n        // Sort the tabs by their index.\r\n        this.tabs.sort((a, b) => a.index - b.index);\r\n\r\n        // Check if there are no current existing active tabs.\r\n        if (!this.activeTab) {\r\n            // If so, we must activate the first available tab.\r\n            this.activateFirstTab();\r\n        }\r\n        // O'wise check if current active tab has been deleted.\r\n        else if (!this.tabs.find(t => t == this.activeTab)) {\r\n            // If so, we must find the closest.\r\n            // Use `setTimeout` as this causes a 'changed after checked' error o'wise.\r\n            setTimeout(() => this.activateClosestTab(this.activeTab));\r\n        }\r\n\r\n        if (this.tabs.length == 0) {\r\n            // Error if there aren't any tabs in the tabset.\r\n            throw new Error(\"You cannot have no tabs!\");\r\n        }\r\n    }\n/**\n * @param {?} tab\n * @return {?}\n */\nprivate onHeaderActiveChanged(tab:Tab) {\r\n        // If the tab has become activated, but was not previously the active tab:\r\n        if (tab.isActive && this.activeTab != tab) {\r\n            // Deactivate all of the tabs.\r\n            this.tabs.filter(t => t != tab).forEach(t => t.isActive = false);\r\n\r\n            // Set the currently active tab to this one.\r\n            this.activeTab = tab;\r\n        }\r\n\r\n        // If the tab has become deactivated, but was previously the active tab:\r\n        if (!tab.isActive && this.activeTab == tab) {\r\n            // Activate the closest tab to it.\r\n            this.activateClosestTab(tab);\r\n        }\r\n    }\n/**\n * @return {?}\n */\npublic activateFirstTab() {\r\n        console.log(\"1\");\r\n        this.activeTab = this.tabs[0];\r\n    }\n/**\n * @param {?} tab\n * @return {?}\n */\npublic activateClosestTab(tab:Tab):void {\r\n        console.log(\"n\");\r\n        let /** @type {?} */ nextAvailable:Tab;\r\n\r\n        // When the exited tab's index is higher than all available tabs,\r\n        if (tab.index >= this.tabs.length) {\r\n            // Activate the last tab.\r\n            nextAvailable = this.tabs[this.tabs.length - 1];\r\n        }\r\n\r\n        // If that didn't work, try the following cases:\r\n        if (!nextAvailable) {\r\n            // When the exited tab no longer exists,\r\n            if (!this.tabs.find(t => t == tab)) {\r\n                // Replace it with a tab at the same index.\r\n                nextAvailable = this.tabs[tab.index];\r\n            }\r\n            // Or if the exited tab still exists,\r\n            else {\r\n                // Go to the tab immediately to the left.\r\n                nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];\r\n            }\r\n        }\r\n        \r\n        // However, if the chosen tab is disabled,\r\n        if (nextAvailable.isDisabled) {\r\n            // Activate the closest available tab to it.\r\n            return this.activateClosestTab(nextAvailable);\r\n        }\r\n\r\n        this.activeTab = nextAvailable;\r\n    }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\r\n    selector: 'sui-tabset',\r\n    template: `<ng-content></ng-content>`\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'_tabHeaders': [{ type: ContentChildren, args: [SuiTabHeader, ] },],\n'_tabContents': [{ type: ContentChildren, args: [SuiTabContent, ] },],\n};\n}\n\nfunction SuiTabset_tsickle_Closure_declarations() {\n/** @type {?} */\nSuiTabset.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nSuiTabset.ctorParameters;\n/** @type {?} */\nSuiTabset.propDecorators;\n/** @type {?} */\nSuiTabset.prototype._tabHeaders;\n/** @type {?} */\nSuiTabset.prototype._tabContents;\n/** @type {?} */\nSuiTabset.prototype.tabs;\n/** @type {?} */\nSuiTabset.prototype._activeTab;\n/** @type {?} */\nSuiTabset.prototype._barrierCount;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}